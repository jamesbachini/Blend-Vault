#![no_std]

use soroban_sdk::{
    contract, contractclient, contractimpl, contracttype, token, Address, Env, Map, String, Vec,
};
use stellar_macros::default_impl;
use stellar_tokens::{
    fungible::{Base, FungibleToken},
    vault::{FungibleVault, Vault},
};

#[contract]
pub struct BlendVaultContract;

// Storage keys for our custom data
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub enum DataKey {
    BlendPool,
    USDCReserveIndex,
    BLNDToken,
    BLNDReserveIndex,
    CometPool,
}

// Blend Protocol types - from the interface provided
#[contracttype]
#[derive(Clone)]
pub struct Request {
    pub request_type: u32,
    pub address: Address,
    pub amount: i128,
}

#[contracttype]
pub struct Positions {
    pub collateral: Map<u32, i128>,
    pub liabilities: Map<u32, i128>,
    pub supply: Map<u32, i128>,
}

// Request types for Blend pool interactions
const REQUEST_TYPE_SUPPLY: u32 = 0;
const REQUEST_TYPE_WITHDRAW: u32 = 1;

// Blend Pool contract client interface
#[contractclient(name = "BlendPoolClient")]
pub trait BlendPoolInterface {
    fn submit(
        env: Env,
        from: Address,
        spender: Address,
        to: Address,
        requests: Vec<Request>,
    ) -> Positions;

    fn get_positions(env: Env, address: Address) -> Positions;

    fn claim(env: Env, from: Address, reserve_token_ids: Vec<u32>, to: Address) -> i128;
}

// Comet Pool contract client interface for BLND-USDC swaps
#[contractclient(name = "CometPoolClient")]
pub trait CometPoolInterface {
    fn swap_exact_amount_in(
        env: Env,
        token_in: Address,
        token_amount_in: i128,
        token_out: Address,
        min_amount_out: i128,
        max_price: i128,
        user: Address,
    ) -> (i128, i128);
}

#[contractimpl]
impl BlendVaultContract {
    /// Initialize the vault
    ///
    /// ### Arguments
    /// * `asset` - The underlying asset address (USDC)
    /// * `decimals_offset` - The decimal offset for share token
    /// * `blend_pool` - The Blend pool contract address
    /// * `usdc_reserve_index` - The reserve index for USDC in the Blend pool
    /// * `blnd_token` - The BLND token address for claiming rewards
    /// * `blnd_reserve_index` - The reserve index for BLND in the Blend pool
    /// * `comet_pool` - The Comet pool contract address for BLND-USDC swaps
    pub fn initialize(
        e: &Env,
        asset: Address,
        decimals_offset: u32,
        blend_pool: Address,
        usdc_reserve_index: u32,
        blnd_token: Address,
        blnd_reserve_index: u32,
        comet_pool: Address,
    ) {
        // Store the Blend pool address and USDC reserve index
        e.storage().instance().set(&DataKey::BlendPool, &blend_pool);
        e.storage()
            .instance()
            .set(&DataKey::USDCReserveIndex, &usdc_reserve_index);

        // Store BLND token, reserve index, and Comet pool for compounding
        e.storage().instance().set(&DataKey::BLNDToken, &blnd_token);
        e.storage()
            .instance()
            .set(&DataKey::BLNDReserveIndex, &blnd_reserve_index);
        e.storage().instance().set(&DataKey::CometPool, &comet_pool);

        // Set the underlying asset and the decimal offset
        Vault::set_asset(e, asset);
        Vault::set_decimals_offset(e, decimals_offset);

        // Initialize metadata for the share token
        Base::set_metadata(
            e,
            Self::decimals(e),
            String::from_str(e, "Blend Vault Token"),
            String::from_str(e, "bVLT"),
        );
    }

    /// Get the Blend pool address
    fn get_blend_pool(e: &Env) -> Address {
        e.storage()
            .instance()
            .get(&DataKey::BlendPool)
            .expect("Blend pool not initialized")
    }

    /// Get the USDC reserve index
    fn get_usdc_reserve_index(e: &Env) -> u32 {
        e.storage()
            .instance()
            .get(&DataKey::USDCReserveIndex)
            .expect("USDC reserve index not initialized")
    }

    /// Get the BLND token address
    fn get_blnd_token(e: &Env) -> Address {
        e.storage()
            .instance()
            .get(&DataKey::BLNDToken)
            .expect("BLND token not initialized")
    }

    /// Get the BLND reserve index
    fn get_blnd_reserve_index(e: &Env) -> u32 {
        e.storage()
            .instance()
            .get(&DataKey::BLNDReserveIndex)
            .expect("BLND reserve index not initialized")
    }

    /// Get the Comet pool address
    fn get_comet_pool(e: &Env) -> Address {
        e.storage()
            .instance()
            .get(&DataKey::CometPool)
            .expect("Comet pool not initialized")
    }

    /// Compound BLND rewards into USDC and re-deposit
    ///
    /// This function performs three steps:
    /// 1. Claims BLND tokens from Blend pool
    /// 2. Swaps BLND for USDC on Comet DEX
    /// 3. Deposits USDC back into Blend pool
    ///
    /// Returns the amount of USDC deposited back into the pool
    pub fn compound(e: &Env) -> i128 {
        let vault_address = e.current_contract_address();
        let pool_address = Self::get_blend_pool(e);
        let blnd_token = Self::get_blnd_token(e);
        let blnd_index = Self::get_blnd_reserve_index(e);
        let comet_pool = Self::get_comet_pool(e);
        let usdc_token = Vault::query_asset(e);

        // Step 1: Claim BLND from Blend pool
        let pool_client = BlendPoolClient::new(e, &pool_address);
        let mut reserve_ids: Vec<u32> = Vec::new(e);
        reserve_ids.push_back(blnd_index);

        let blnd_claimed = pool_client.claim(&vault_address, &reserve_ids, &vault_address);

        // If no BLND claimed, return early
        if blnd_claimed <= 0 {
            return 0;
        }

        // Step 2: Swap BLND for USDC on Comet
        let comet_client = CometPoolClient::new(e, &comet_pool);

        // Use a reasonable slippage tolerance (0.5% = 0.005)
        // min_amount_out = 0 for now (can be improved with price oracle)
        // max_price = i128::MAX to accept any price
        let (usdc_received, _) = comet_client.swap_exact_amount_in(
            &blnd_token,
            &blnd_claimed,
            &usdc_token,
            &0, // min_amount_out - set to 0 for simplicity (no price protection)
            &i128::MAX, // max_price - accept any price
            &vault_address,
        );

        // If no USDC received, return early
        if usdc_received <= 0 {
            return 0;
        }

        // Step 3: Deposit USDC back into Blend pool
        let mut requests: Vec<Request> = Vec::new(e);
        requests.push_back(Request {
            request_type: REQUEST_TYPE_SUPPLY,
            address: usdc_token,
            amount: usdc_received,
        });

        pool_client.submit(&vault_address, &vault_address, &vault_address, &requests);

        usdc_received
    }

    /// Try to compound rewards, but don't fail if there are no rewards
    /// This is a safety wrapper used before withdrawals
    fn try_compound(e: &Env) {
        // Use a Result-like pattern with panic catching via environmental context
        // In Soroban, we can't easily catch panics, so we'll just call compound
        // The compound function already returns 0 if no rewards, so it won't panic
        let _ = Self::compound(e);
    }
}

#[default_impl]
#[contractimpl]
impl FungibleToken for BlendVaultContract {
    type ContractType = Vault;

    fn decimals(e: &Env) -> u32 {
        Vault::decimals(e)
    }
}

#[contractimpl]
impl FungibleVault for BlendVaultContract {
    fn query_asset(e: &Env) -> Address {
        Vault::query_asset(e)
    }

    /// Override total_assets to query the actual balance in Blend pool
    fn total_assets(e: &Env) -> i128 {
        let pool_address = Self::get_blend_pool(e);
        let usdc_index = Self::get_usdc_reserve_index(e);
        let vault_address = e.current_contract_address();

        // Create pool client to query positions
        let pool_client = BlendPoolClient::new(e, &pool_address);

        // Get the vault's positions in the Blend pool
        let positions = pool_client.get_positions(&vault_address);

        // Return the supply amount for USDC (our underlying asset)
        // The supply map uses the reserve index as key
        positions.supply.get(usdc_index).unwrap_or(0)
    }

    fn convert_to_shares(e: &Env, assets: i128) -> i128 {
        Vault::convert_to_shares(e, assets)
    }

    fn convert_to_assets(e: &Env, shares: i128) -> i128 {
        Vault::convert_to_assets(e, shares)
    }

    fn max_deposit(e: &Env, receiver: Address) -> i128 {
        Vault::max_deposit(e, receiver)
    }

    fn preview_deposit(e: &Env, assets: i128) -> i128 {
        Vault::preview_deposit(e, assets)
    }

    fn max_mint(e: &Env, receiver: Address) -> i128 {
        Vault::max_mint(e, receiver)
    }

    fn preview_mint(e: &Env, shares: i128) -> i128 {
        Vault::preview_mint(e, shares)
    }

    fn max_withdraw(e: &Env, owner: Address) -> i128 {
        Vault::max_withdraw(e, owner)
    }

    fn preview_withdraw(e: &Env, assets: i128) -> i128 {
        Vault::preview_withdraw(e, assets)
    }

    fn max_redeem(e: &Env, owner: Address) -> i128 {
        Vault::max_redeem(e, owner)
    }

    fn preview_redeem(e: &Env, shares: i128) -> i128 {
        Vault::preview_redeem(e, shares)
    }

    /// Deposit assets into the vault and supply to Blend
    fn deposit(
        e: &Env,
        assets: i128,
        receiver: Address,
        from: Address,
        operator: Address,
    ) -> i128 {
        operator.require_auth();

        let asset = Vault::query_asset(e);
        let vault_address = e.current_contract_address();
        let pool_address = Self::get_blend_pool(e);

        // Calculate shares to mint
        let shares = Vault::preview_deposit(e, assets);

        // Transfer USDC from user to vault
        let token_client = token::TokenClient::new(e, &asset);
        token_client.transfer(&from, &vault_address, &assets);

        // Supply USDC to Blend pool
        let pool_client = BlendPoolClient::new(e, &pool_address);

        // Create supply request
        let mut requests: Vec<Request> = Vec::new(e);
        requests.push_back(Request {
            request_type: REQUEST_TYPE_SUPPLY,
            address: asset.clone(),
            amount: assets,
        });

        // Submit the supply request to Blend
        pool_client.submit(&vault_address, &vault_address, &vault_address, &requests);

        // Mint shares to receiver
        Base::mint(e, &receiver, shares);

        shares
    }

    /// Mint shares by depositing assets into the vault and Blend
    fn mint(
        e: &Env,
        shares: i128,
        receiver: Address,
        from: Address,
        operator: Address,
    ) -> i128 {
        operator.require_auth();

        let asset = Vault::query_asset(e);
        let vault_address = e.current_contract_address();
        let pool_address = Self::get_blend_pool(e);

        // Calculate assets needed
        let assets = Vault::preview_mint(e, shares);

        // Transfer USDC from user to vault
        let token_client = token::TokenClient::new(e, &asset);
        token_client.transfer(&from, &vault_address, &assets);

        // Supply USDC to Blend pool
        let pool_client = BlendPoolClient::new(e, &pool_address);

        let mut requests: Vec<Request> = Vec::new(e);
        requests.push_back(Request {
            request_type: REQUEST_TYPE_SUPPLY,
            address: asset.clone(),
            amount: assets,
        });

        pool_client.submit(&vault_address, &vault_address, &vault_address, &requests);

        // Mint shares to receiver
        Base::mint(e, &receiver, shares);

        assets
    }

    /// Withdraw assets from the vault by redeeming from Blend
    fn withdraw(
        e: &Env,
        assets: i128,
        receiver: Address,
        owner: Address,
        operator: Address,
    ) -> i128 {
        operator.require_auth();

        // Try to compound rewards before withdrawal
        // Note: Disabled for now to avoid authorization conflicts in nested calls
        // Self::try_compound(e);

        let asset = Vault::query_asset(e);
        let vault_address = e.current_contract_address();
        let pool_address = Self::get_blend_pool(e);

        // Calculate shares to burn
        let shares = Vault::preview_withdraw(e, assets);

        // Withdraw USDC from Blend pool
        let pool_client = BlendPoolClient::new(e, &pool_address);

        let mut requests: Vec<Request> = Vec::new(e);
        requests.push_back(Request {
            request_type: REQUEST_TYPE_WITHDRAW,
            address: asset.clone(),
            amount: assets,
        });

        pool_client.submit(&vault_address, &vault_address, &vault_address, &requests);

        // Burn shares from owner
        Base::burn(e, &owner, shares);

        // Transfer USDC from vault to receiver
        let token_client = token::TokenClient::new(e, &asset);
        token_client.transfer(&vault_address, &receiver, &assets);

        shares
    }

    /// Redeem shares from the vault by withdrawing from Blend
    fn redeem(
        e: &Env,
        shares: i128,
        receiver: Address,
        owner: Address,
        operator: Address,
    ) -> i128 {
        operator.require_auth();

        // Try to compound rewards before redemption
        // Note: Disabled for now to avoid authorization conflicts in nested calls
        // Self::try_compound(e);

        let asset = Vault::query_asset(e);
        let vault_address = e.current_contract_address();
        let pool_address = Self::get_blend_pool(e);

        // Calculate assets to withdraw
        let assets = Vault::preview_redeem(e, shares);

        // Withdraw USDC from Blend pool
        let pool_client = BlendPoolClient::new(e, &pool_address);

        let mut requests: Vec<Request> = Vec::new(e);
        requests.push_back(Request {
            request_type: REQUEST_TYPE_WITHDRAW,
            address: asset.clone(),
            amount: assets,
        });

        pool_client.submit(&vault_address, &vault_address, &vault_address, &requests);

        // Burn shares from owner
        Base::burn(e, &owner, shares);

        // Transfer USDC from vault to receiver
        let token_client = token::TokenClient::new(e, &asset);
        token_client.transfer(&vault_address, &receiver, &assets);

        assets
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use sep_41_token::testutils::{MockTokenClient, MockTokenWASM};
    use soroban_sdk::{testutils::Address as _, Address, Env, String as SorobanString};

    // Storage keys for MockBlendPool
    #[contracttype]
    #[derive(Clone)]
    pub enum MockPoolDataKey {
        Positions(Address),
    }

    // Mock Blend Pool Contract
    #[contract]
    pub struct MockBlendPool;

    #[contractimpl]
    impl MockBlendPool {
        pub fn submit(
            env: Env,
            _from: Address,
            _spender: Address,
            to: Address,
            requests: Vec<Request>,
        ) -> Positions {
            // Get current positions from storage or create new
            let mut positions: Positions = env
                .storage()
                .persistent()
                .get(&MockPoolDataKey::Positions(to.clone()))
                .unwrap_or_else(|| {
                    let supply_map: Map<u32, i128> = Map::new(&env);
                    let collateral_map: Map<u32, i128> = Map::new(&env);
                    let liabilities_map: Map<u32, i128> = Map::new(&env);
                    Positions {
                        collateral: collateral_map,
                        liabilities: liabilities_map,
                        supply: supply_map,
                    }
                });

            // For each request, update the positions
            for request in requests.iter() {
                if request.request_type == REQUEST_TYPE_SUPPLY {
                    // Get current supply and add to it
                    let current = positions.supply.get(0).unwrap_or(0);
                    positions.supply.set(0, current + request.amount);
                } else if request.request_type == REQUEST_TYPE_WITHDRAW {
                    // Get current supply and subtract from it
                    let current = positions.supply.get(0).unwrap_or(0);
                    positions.supply.set(0, current - request.amount);
                }
            }

            // Store updated positions
            env.storage()
                .persistent()
                .set(&MockPoolDataKey::Positions(to.clone()), &positions);

            positions
        }

        pub fn get_positions(env: Env, address: Address) -> Positions {
            // Return the stored positions or empty positions
            env.storage()
                .persistent()
                .get(&MockPoolDataKey::Positions(address))
                .unwrap_or_else(|| {
                    let supply_map: Map<u32, i128> = Map::new(&env);
                    let collateral_map: Map<u32, i128> = Map::new(&env);
                    let liabilities_map: Map<u32, i128> = Map::new(&env);
                    Positions {
                        collateral: collateral_map,
                        liabilities: liabilities_map,
                        supply: supply_map,
                    }
                })
        }

        pub fn claim(
            _env: Env,
            _from: Address,
            _reserve_token_ids: Vec<u32>,
            _to: Address,
        ) -> i128 {
            // Mock returns 1000 BLND tokens (with 7 decimals = 0.001 BLND)
            1000_0000000
        }
    }

    // Mock Comet Pool Contract for DEX swaps
    #[contract]
    pub struct MockCometPool;

    #[contractimpl]
    impl MockCometPool {
        pub fn swap_exact_amount_in(
            _env: Env,
            _token_in: Address,
            token_amount_in: i128,
            _token_out: Address,
            _min_amount_out: i128,
            _max_price: i128,
            _user: Address,
        ) -> (i128, i128) {
            // Simple 1:1 mock swap ratio for testing
            // In reality BLND:USDC would have a different ratio
            let amount_out = token_amount_in;
            let spot_price = 1_0000000; // Mock spot price

            // For simplicity in tests, we don't actually transfer tokens
            // The mock just returns the swap amounts

            (amount_out, spot_price)
        }
    }

    // Test fixture structure
    struct TestFixture<'a> {
        env: Env,
        admin: Address,
        user: Address,
        usdc_token: Address,
        usdc_client: MockTokenClient<'a>,
        blnd_token: Address,
        blnd_client: MockTokenClient<'a>,
        blend_pool: Address,
        comet_pool: Address,
        vault: Address,
        vault_client: BlendVaultContractClient<'a>,
    }

    impl<'a> TestFixture<'a> {
        fn new() -> Self {
            let env = Env::default();
            // Don't use mock_all_auths() as it causes issues with nested contract calls
            // Instead, we'll mock auth per operation using set_auths()

            let admin = Address::generate(&env);
            let user = Address::generate(&env);

            // Deploy USDC token
            let usdc_token = env.register_contract_wasm(None, MockTokenWASM);
            let usdc_client = MockTokenClient::new(&env, &usdc_token);
            usdc_client.initialize(
                &admin,
                &7,
                &SorobanString::from_str(&env, "USD Coin"),
                &SorobanString::from_str(&env, "USDC"),
            );

            // Deploy BLND token
            let blnd_token = env.register_contract_wasm(None, MockTokenWASM);
            let blnd_client = MockTokenClient::new(&env, &blnd_token);
            blnd_client.initialize(
                &admin,
                &7,
                &SorobanString::from_str(&env, "Blend Token"),
                &SorobanString::from_str(&env, "BLND"),
            );

            // Deploy mock Blend Pool
            let blend_pool = env.register_contract(None, MockBlendPool);

            // Deploy mock Comet Pool
            let comet_pool = env.register_contract(None, MockCometPool);

            // Deploy vault contract
            let vault = env.register_contract(None, BlendVaultContract);
            let vault_client = BlendVaultContractClient::new(&env, &vault);

            // Initialize vault
            vault_client.initialize(
                &usdc_token,
                &0, // decimals_offset
                &blend_pool,
                &0, // usdc_reserve_index
                &blnd_token,
                &1, // blnd_reserve_index
                &comet_pool,
            );

            // Mint USDC to user for testing
            usdc_client.mint(&user, &1_000_000_0000000); // 1M USDC

            // Mint BLND to blend pool for rewards
            blnd_client.mint(&blend_pool, &1_000_000_0000000);

            // Mint USDC to comet pool for swaps
            usdc_client.mint(&comet_pool, &1_000_000_0000000);

            Self {
                env,
                admin,
                user,
                usdc_token,
                usdc_client,
                blnd_token,
                blnd_client,
                blend_pool,
                comet_pool,
                vault,
                vault_client,
            }
        }
    }

    #[test]
    fn test_initialization() {
        let fixture = TestFixture::new();

        // Check token metadata
        assert_eq!(
            fixture.vault_client.name(),
            SorobanString::from_str(&fixture.env, "Blend Vault Token")
        );
        assert_eq!(
            fixture.vault_client.symbol(),
            SorobanString::from_str(&fixture.env, "bVLT")
        );
        assert_eq!(fixture.vault_client.decimals(), 7);

        // Check asset
        assert_eq!(fixture.vault_client.query_asset(), fixture.usdc_token);

        // Check initial supply
        assert_eq!(fixture.vault_client.total_supply(), 0);
    }

    #[test]
    fn test_deposit() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000; // 1000 USDC

        // User deposits USDC
        let shares = fixture
            .vault_client
            .mock_all_auths()
            .deposit(&deposit_amount, &fixture.user, &fixture.user, &fixture.user);

        // Check shares minted (should be 1:1 for first deposit)
        assert_eq!(shares, deposit_amount);

        // Check user's share balance
        assert_eq!(fixture.vault_client.balance(&fixture.user), shares);

        // Check total supply
        assert_eq!(fixture.vault_client.total_supply(), shares);

        // Check USDC was transferred from user
        assert_eq!(
            fixture.usdc_client.balance(&fixture.user),
            1_000_000_0000000 - deposit_amount
        );
    }

    #[test]
    fn test_multiple_deposits() {
        let fixture = TestFixture::new();
        let first_deposit = 1000_0000000; // 1000 USDC
        let second_deposit = 500_0000000; // 500 USDC

        // First deposit
        let shares1 = fixture
            .vault_client
            .mock_all_auths()
            .deposit(&first_deposit, &fixture.user, &fixture.user, &fixture.user);

        // Second deposit
        let shares2 = fixture
            .vault_client
            .mock_all_auths()
            .deposit(&second_deposit, &fixture.user, &fixture.user, &fixture.user);

        // Total shares should equal total deposits (1:1 ratio with no yield)
        assert_eq!(shares1 + shares2, first_deposit + second_deposit);
        assert_eq!(
            fixture.vault_client.balance(&fixture.user),
            first_deposit + second_deposit
        );
    }

    #[test]
    fn test_mint() {
        let fixture = TestFixture::new();
        let shares_to_mint = 1000_0000000;

        // User mints shares
        let assets_deposited = fixture
            .vault_client
            .mock_all_auths()
            .mint(&shares_to_mint, &fixture.user, &fixture.user, &fixture.user);

        // For first mint, should be 1:1
        assert_eq!(assets_deposited, shares_to_mint);

        // Check user's share balance
        assert_eq!(fixture.vault_client.balance(&fixture.user), shares_to_mint);

        // Check USDC was transferred
        assert_eq!(
            fixture.usdc_client.balance(&fixture.user),
            1_000_000_0000000 - assets_deposited
        );
    }

    #[test]
    fn test_withdraw() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // First deposit
        fixture
            .vault_client
            .mock_all_auths()
            .deposit(&deposit_amount, &fixture.user, &fixture.user, &fixture.user);

        // Then withdraw half
        let withdraw_amount = 500_0000000;
        let shares_burned = fixture
            .vault_client
            .mock_all_auths()
            .withdraw(&withdraw_amount, &fixture.user, &fixture.user, &fixture.user);

        // Shares burned should equal amount withdrawn (1:1 ratio)
        assert_eq!(shares_burned, withdraw_amount);

        // Check remaining shares
        assert_eq!(
            fixture.vault_client.balance(&fixture.user),
            deposit_amount - shares_burned
        );

        // Check USDC balance (started with 1M, deposited 1000, withdrew 500)
        assert_eq!(
            fixture.usdc_client.balance(&fixture.user),
            1_000_000_0000000 - deposit_amount + withdraw_amount
        );
    }

    #[test]
    fn test_redeem() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // First deposit
        let shares = fixture
            .vault_client
            .mock_all_auths()
            .deposit(&deposit_amount, &fixture.user, &fixture.user, &fixture.user);

        // Then redeem half the shares
        let shares_to_redeem = shares / 2;
        let assets_received = fixture
            .vault_client
            .mock_all_auths()
            .redeem(&shares_to_redeem, &fixture.user, &fixture.user, &fixture.user);

        // Assets should equal shares (1:1 ratio)
        assert_eq!(assets_received, shares_to_redeem);

        // Check remaining shares
        assert_eq!(
            fixture.vault_client.balance(&fixture.user),
            shares - shares_to_redeem
        );
    }

    #[test]
    fn test_full_deposit_and_withdraw_cycle() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;
        let initial_balance = fixture.usdc_client.balance(&fixture.user);

        // Deposit
        let shares = fixture
            .vault_client
            .mock_all_auths()
            .deposit(&deposit_amount, &fixture.user, &fixture.user, &fixture.user);

        // Withdraw all
        fixture
            .vault_client
            .mock_all_auths()
            .redeem(&shares, &fixture.user, &fixture.user, &fixture.user);

        // Should have original balance back
        assert_eq!(fixture.usdc_client.balance(&fixture.user), initial_balance);

        // Should have no shares
        assert_eq!(fixture.vault_client.balance(&fixture.user), 0);
    }

    #[test]
    fn test_preview_deposit() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // Preview before depositing
        let expected_shares = fixture.vault_client.preview_deposit(&deposit_amount);

        // Actually deposit
        let actual_shares = fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Should match
        assert_eq!(expected_shares, actual_shares);
    }

    #[test]
    fn test_preview_mint() {
        let fixture = TestFixture::new();
        let shares_to_mint = 1000_0000000;

        // Preview before minting
        let expected_assets = fixture.vault_client.preview_mint(&shares_to_mint);

        // Actually mint
        let actual_assets = fixture.vault_client.mint(
            &shares_to_mint,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Should match
        assert_eq!(expected_assets, actual_assets);
    }

    #[test]
    fn test_preview_withdraw() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // First deposit
        fixture
            .vault_client
            .mock_all_auths()
            .deposit(&deposit_amount, &fixture.user, &fixture.user, &fixture.user);

        let withdraw_amount = 500_0000000;

        // Preview before withdrawing
        let expected_shares = fixture.vault_client.preview_withdraw(&withdraw_amount);

        // Actually withdraw
        let actual_shares = fixture
            .vault_client
            .mock_all_auths()
            .withdraw(&withdraw_amount, &fixture.user, &fixture.user, &fixture.user);

        // Should match
        assert_eq!(expected_shares, actual_shares);
    }

    #[test]
    fn test_preview_redeem() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // First deposit
        let shares = fixture
            .vault_client
            .mock_all_auths()
            .deposit(&deposit_amount, &fixture.user, &fixture.user, &fixture.user);

        let shares_to_redeem = shares / 2;

        // Preview before redeeming
        let expected_assets = fixture.vault_client.preview_redeem(&shares_to_redeem);

        // Actually redeem
        let actual_assets = fixture
            .vault_client
            .mock_all_auths()
            .redeem(&shares_to_redeem, &fixture.user, &fixture.user, &fixture.user);

        // Should match
        assert_eq!(expected_assets, actual_assets);
    }

    #[test]
    fn test_convert_to_shares() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // Before any deposits
        let shares = fixture.vault_client.convert_to_shares(&deposit_amount);
        assert_eq!(shares, deposit_amount); // 1:1 when empty

        // After a deposit
        fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        let shares2 = fixture.vault_client.convert_to_shares(&deposit_amount);
        assert_eq!(shares2, deposit_amount); // Still 1:1 with no yield
    }

    #[test]
    fn test_convert_to_assets() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // Make a deposit first
        let shares = fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Convert back
        let assets = fixture.vault_client.convert_to_assets(&shares);
        assert_eq!(assets, deposit_amount);
    }

    #[test]
    fn test_max_deposit() {
        let fixture = TestFixture::new();

        let max = fixture.vault_client.max_deposit(&fixture.user);
        // Should return i128::MAX by default
        assert_eq!(max, i128::MAX);
    }

    #[test]
    fn test_max_mint() {
        let fixture = TestFixture::new();

        let max = fixture.vault_client.max_mint(&fixture.user);
        // Should return i128::MAX by default
        assert_eq!(max, i128::MAX);
    }

    #[test]
    fn test_max_withdraw() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // Before deposit, max should be 0
        let max_before = fixture.vault_client.max_withdraw(&fixture.user);
        assert_eq!(max_before, 0);

        // After deposit
        fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        let max_after = fixture.vault_client.max_withdraw(&fixture.user);
        assert_eq!(max_after, deposit_amount);
    }

    #[test]
    fn test_max_redeem() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // Before deposit, max should be 0
        let max_before = fixture.vault_client.max_redeem(&fixture.user);
        assert_eq!(max_before, 0);

        // After deposit
        let shares = fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        let max_after = fixture.vault_client.max_redeem(&fixture.user);
        assert_eq!(max_after, shares);
    }

    #[test]
    fn test_zero_deposit() {
        let fixture = TestFixture::new();

        let shares = fixture
            .vault_client
            .deposit(&0, &fixture.user, &fixture.user, &fixture.user);

        assert_eq!(shares, 0);
        assert_eq!(fixture.vault_client.balance(&fixture.user), 0);
    }

    #[test]
    fn test_zero_mint() {
        let fixture = TestFixture::new();

        let assets = fixture
            .vault_client
            .mint(&0, &fixture.user, &fixture.user, &fixture.user);

        assert_eq!(assets, 0);
        assert_eq!(fixture.vault_client.balance(&fixture.user), 0);
    }

    #[test]
    #[should_panic]
    fn test_withdraw_more_than_balance() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // Deposit
        fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Try to withdraw more than deposited (should panic)
        fixture.vault_client.withdraw(
            &(deposit_amount + 1),
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );
    }

    #[test]
    #[should_panic]
    fn test_redeem_more_than_shares() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // Deposit
        let shares = fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Try to redeem more shares than owned (should panic)
        fixture.vault_client.redeem(
            &(shares + 1),
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );
    }

    #[test]
    fn test_total_assets_empty() {
        let fixture = TestFixture::new();

        // With no deposits, total assets should be 0
        assert_eq!(fixture.vault_client.total_assets(), 0);
    }

    #[test]
    fn test_total_assets_after_deposit() {
        let fixture = TestFixture::new();
        let deposit_amount = 1000_0000000;

        // Deposit
        fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Note: With our stateful mock, total_assets should now reflect the deposit
        let total = fixture.vault_client.total_assets();
        // The mock now properly tracks state, so total should equal deposit
        assert_eq!(total, deposit_amount);
    }

    #[test]
    fn test_multiple_users_deposit() {
        let fixture = TestFixture::new();
        let user2 = Address::generate(&fixture.env);

        // Mint USDC to second user
        fixture.usdc_client.mint(&user2, &1_000_000_0000000);

        let deposit1 = 1000_0000000;
        let deposit2 = 2000_0000000;

        // First user deposits
        let shares1 = fixture.vault_client.deposit(
            &deposit1,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Second user deposits
        let shares2 = fixture
            .vault_client
            .deposit(&deposit2, &user2, &user2, &user2);

        // Check balances
        assert_eq!(fixture.vault_client.balance(&fixture.user), shares1);
        assert_eq!(fixture.vault_client.balance(&user2), shares2);

        // Total supply should be sum of both
        assert_eq!(fixture.vault_client.total_supply(), shares1 + shares2);
    }

    #[test]
    fn test_compound_with_rewards() {
        let fixture = TestFixture::new();

        // First make a deposit so vault has position in Blend
        let deposit_amount = 1000_0000000;
        fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Call compound - should claim BLND and swap to USDC
        let usdc_deposited = fixture.vault_client.compound();

        // Mock returns 1:1 swap, so should deposit some USDC
        // The mock claim returns 1000 BLND (with 7 decimals)
        assert!(usdc_deposited > 0);
    }

    #[test]
    fn test_compound_without_rewards() {
        let _fixture = TestFixture::new();

        // Create a fixture where claim returns 0
        // For now, calling compound when there are no rewards should return 0
        // We'll test this with our mock which has a fixed return

        // This test would need a modified mock to return 0 rewards
        // For now, we know the mock returns a fixed amount
    }

    #[test]
    fn test_deposit_different_receiver() {
        let fixture = TestFixture::new();
        let receiver = Address::generate(&fixture.env);
        let deposit_amount = 1000_0000000;

        // User deposits but shares go to receiver
        let shares = fixture.vault_client.deposit(
            &deposit_amount,
            &receiver,
            &fixture.user,
            &fixture.user,
        );

        // Receiver should have the shares
        assert_eq!(fixture.vault_client.balance(&receiver), shares);

        // User should have paid the USDC
        assert_eq!(
            fixture.usdc_client.balance(&fixture.user),
            1_000_000_0000000 - deposit_amount
        );

        // Original user should have no shares
        assert_eq!(fixture.vault_client.balance(&fixture.user), 0);
    }

    #[test]
    fn test_withdraw_different_receiver() {
        let fixture = TestFixture::new();
        let receiver = Address::generate(&fixture.env);
        let deposit_amount = 1000_0000000;

        // First deposit
        fixture
            .vault_client
            .mock_all_auths()
            .deposit(&deposit_amount, &fixture.user, &fixture.user, &fixture.user);

        let initial_receiver_balance = fixture.usdc_client.balance(&receiver);

        // Withdraw to different receiver
        let withdraw_amount = 500_0000000;
        fixture
            .vault_client
            .mock_all_auths()
            .withdraw(&withdraw_amount, &receiver, &fixture.user, &fixture.user);

        // Receiver should have gotten the USDC
        assert_eq!(
            fixture.usdc_client.balance(&receiver),
            initial_receiver_balance + withdraw_amount
        );
    }

    #[test]
    fn test_fungible_token_interface() {
        let fixture = TestFixture::new();

        // Test name
        assert_eq!(
            fixture.vault_client.name(),
            SorobanString::from_str(&fixture.env, "Blend Vault Token")
        );

        // Test symbol
        assert_eq!(
            fixture.vault_client.symbol(),
            SorobanString::from_str(&fixture.env, "bVLT")
        );

        // Test decimals
        assert_eq!(fixture.vault_client.decimals(), 7);

        // Test total supply starts at 0
        assert_eq!(fixture.vault_client.total_supply(), 0);

        // Test balance
        assert_eq!(fixture.vault_client.balance(&fixture.user), 0);
    }

    #[test]
    fn test_allowance_and_transfer_from() {
        let fixture = TestFixture::new();
        let spender = Address::generate(&fixture.env);
        let deposit_amount = 1000_0000000;

        // User deposits to get shares
        fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // User approves spender
        let shares = fixture.vault_client.balance(&fixture.user);
        fixture
            .vault_client
            .approve(&fixture.user, &spender, &shares, &200);

        // Check allowance
        assert_eq!(
            fixture.vault_client.allowance(&fixture.user, &spender),
            shares
        );
    }

    #[test]
    fn test_transfer_shares() {
        let fixture = TestFixture::new();
        let recipient = Address::generate(&fixture.env);
        let deposit_amount = 1000_0000000;

        // User deposits to get shares
        let shares = fixture.vault_client.deposit(
            &deposit_amount,
            &fixture.user,
            &fixture.user,
            &fixture.user,
        );

        // Transfer half the shares
        let transfer_amount = shares / 2;
        fixture
            .vault_client
            .transfer(&fixture.user, &recipient, &transfer_amount);

        // Check balances
        assert_eq!(
            fixture.vault_client.balance(&fixture.user),
            shares - transfer_amount
        );
        assert_eq!(fixture.vault_client.balance(&recipient), transfer_amount);
    }
}
